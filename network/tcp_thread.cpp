#include "tcp_thread.h"

TCP_Thread::TCP_Thread(int ID, QObject *parent) :
    QThread(parent)
{
    this->socketDescriptor = ID;
}

TCP_Thread::~TCP_Thread()
{
    delete socket;
}

/**
 * @brief TCP_Thread::run The server TCP loop to handle sockets.
 */
void TCP_Thread::run()
{
    // thread starts here
    qDebug() << socketDescriptor << " Starting thread";
    socket = new QTcpSocket();
    if(!socket->setSocketDescriptor(this->socketDescriptor))
    {
        emit error(socket->error());
        return;
    }

    connect(socket, SIGNAL(readyRead()), this, SLOT(readyRead()),Qt::DirectConnection);
    connect(socket, SIGNAL(disconnected()), this, SLOT(disconnected()),Qt::DirectConnection);
    qDebug() << socketDescriptor << " Client connected";

    // make this thread a loop
    exec();
}

void TCP_Thread::readyRead()
{
    receive_raw_stereo_image();
}

/**
 * @brief TCP_Thread::mat_to_qByteArray Convert a cv::Mat image to a QByteArray
 * @param image the image to convert
 * @return the QByteArray of this image
 */
QByteArray TCP_Thread::mat_to_qByteArray(cv::Mat image){
    std::vector<uint8_t> buffer;
    cv::imencode(".png", image, buffer);
    QByteArray byteArray = QByteArray::fromRawData((const char*)buffer.data(), buffer.size());
    QString base64Image(byteArray.toBase64());

    return byteArray;
}

/**
 * @brief TCP_Thread::send_depth_map Send the depth map generated by first sending a message to prepare the client for the image exchange
 * @param depth_map the image to send thought socket
 */
void TCP_Thread::send_order(int order){
    qDebug() << "\n[INFO] Order received !\nSending the order message to the client: " << order;

//    QByteArray data_ack = socket->readAll();    //Wait for the answer of unity/robot/...
//    if(data_ack == "ready"){
        qDebug() << socketDescriptor << "Ready to upload the dorder ";
        socket->write(QByteArray::number(order)); //Send back the depth map generated

        qDebug() << "ORDER SENT" ;
//    }

}

/**
 * @brief TCP_Thread::receive_raw_stereo_image function that receive a pair image throught tcp socket and store it into ImgCv and give it to the disparity map window for processing.
 * @return true if an image has been correctly loaded, else false
 */
bool TCP_Thread::receive_raw_stereo_image(){
    QByteArray data_received;
    while (socket->waitForReadyRead(10))
        data_received += socket->readAll();

    //qDebug() << "\n\n" << socketDescriptor << " Data in: " << data_received;

    QImage received_image_qimg = QImage::fromData(data_received, "JPG");    //Crash si l'image est dans un autre format (ie. la fille en rouge qui est en png)

    if(received_image_qimg.isNull()){
        qDebug("Image is null");
        return false;
    }
    int order(0);

    emit send_raw_images(imagecv::qimage_to_mat(received_image_qimg), order);

    ImgCv image_to_analyze(imagecv::qimage_to_mat(received_image_qimg)
, true);
    cv::imshow("Received image", image_to_analyze);

    qDebug("Image well received.");

//    send_order(order);
    std::cout << "[INFO] in receive_raw_stereo_image ::order " << order << std::endl;
    std::string tabOrder;
    tabOrder += char(order);
    std::cout << "order in byte " << char(tabOrder.c_str()[0]) -'0' <<
                 "int test 1" << int(tabOrder.c_str()[0]) << std::endl;
    socket->write(QByteArray::fromStdString(tabOrder));
    data_received.clear();
    qDebug("Disparity map loaded");

    return true;
}


/**
 * @brief TCP_Thread::disconnected Summoned when the client socket disconnect. Hide the current parameters window and close his socket
 */
void TCP_Thread::disconnected()
{
    qDebug() << socketDescriptor << " Disconnected";
    socket->deleteLater();
    exit(0);
}
